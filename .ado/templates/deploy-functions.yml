# Backend Deployment Template
# Deploys Azure Functions from unified artifact to target environment

parameters:
  - name: environment
    type: string
  - name: azureSubscription
    type: string
  - name: functionAppName
    type: string
  - name: resourceGroupName
    type: string
  - name: artifactName
    type: string
    default: "drop"
  - name: runSmokeTests
    type: boolean
    default: true

steps:
  # Download unified artifact
  - task: DownloadBuildArtifacts@1
    displayName: "Download Unified Artifact"
    inputs:
      buildType: "current"
      downloadType: "single"
      artifactName: "${{ parameters.artifactName }}"
      downloadPath: "$(System.ArtifactsDirectory)"

  # Display artifact contents for verification
  - script: |
      echo "=========================================="
      echo "ARTIFACT CONTENTS"
      echo "=========================================="
      echo ""
      echo "Artifact location: $(System.ArtifactsDirectory)/${{ parameters.artifactName }}"
      echo ""
      echo "Directory structure:"
      tree -L 3 $(System.ArtifactsDirectory)/${{ parameters.artifactName }} || ls -R $(System.ArtifactsDirectory)/${{ parameters.artifactName }}
      echo ""
      echo "Functions directory contents:"
      ls -lah $(System.ArtifactsDirectory)/${{ parameters.artifactName }}/functions/
      echo ""
      echo "=========================================="
    displayName: "Display Artifact Contents"

  # Verify artifact integrity using checksums
  - script: |
      cd $(System.ArtifactsDirectory)/${{ parameters.artifactName }}

      if [ ! -f "checksums.txt" ]; then
        echo "##vso[task.logissue type=warning]Checksums file not found - skipping integrity verification"
        exit 0
      fi

      echo "Verifying artifact integrity..."
      sha256sum -c checksums.txt

      if [ $? -eq 0 ]; then
        echo "✓ Artifact integrity verified successfully"
      else
        echo "##vso[task.logissue type=error]Artifact integrity verification failed"
        exit 1
      fi
    displayName: "Verify Artifact Integrity"
    continueOnError: true

  # Display release manifest
  - script: |
      if [ -f "$(System.ArtifactsDirectory)/${{ parameters.artifactName }}/release.json" ]; then
        echo "=========================================="
        echo "RELEASE MANIFEST"
        echo "=========================================="
        cat $(System.ArtifactsDirectory)/${{ parameters.artifactName }}/release.json
        echo ""
        echo "=========================================="
      else
        echo "##vso[task.logissue type=warning]Release manifest not found"
      fi
    displayName: "Display Release Manifest"

  # Calculate deterministic hash for functions artifact to enable diff-based deployments
  - script: |
      set -euo pipefail

      ARTIFACT_DIR="$(System.ArtifactsDirectory)/${{ parameters.artifactName }}/functions"

      if [ ! -d "$ARTIFACT_DIR" ]; then
        echo "##vso[task.logissue type=error]Functions artifact directory not found at $ARTIFACT_DIR"
        exit 1
      fi

      echo "Calculating functions artifact hash..."

      export ARTIFACT_DIR
      HASH=$(python3 - <<'PY'
import hashlib
import os

root = os.environ["ARTIFACT_DIR"]
digest = hashlib.sha256()

for dirpath, _, filenames in os.walk(root):
    filenames.sort()
    rel_dir = os.path.relpath(dirpath, root)
    if rel_dir == ".":
        rel_dir = ""
    for filename in filenames:
        rel_path = os.path.normpath(os.path.join(rel_dir, filename))
        digest.update(rel_path.replace(os.sep, "/").encode("utf-8"))
        file_path = os.path.join(dirpath, filename)
        with open(file_path, "rb") as handle:
            for chunk in iter(lambda: handle.read(1024 * 1024), b""):
                digest.update(chunk)

print(digest.hexdigest())
PY
)

      HASH=$(echo "$HASH" | tr -d '\n\r')

      if [ -z "$HASH" ]; then
        echo "##vso[task.logissue type=error]Failed to compute artifact hash"
        exit 1
      fi

      echo "Functions artifact hash: $HASH"
      echo "##vso[task.setvariable variable=FunctionsArtifactHash]$HASH"
      echo "##vso[task.setvariable variable=ShouldDeployFunctions]true"
    displayName: "Compute Functions Artifact Hash"

  # Compare artifact hash with deployed hash stored in app settings
  - task: AzureCLI@2
    displayName: "Evaluate Functions Deployment Hash"
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      scriptType: "bash"
      scriptLocation: "inlineScript"
      inlineScript: |
        set -euo pipefail

        ARTIFACT_HASH="$(FunctionsArtifactHash)"
        APP_NAME="${{ parameters.functionAppName }}"
        RESOURCE_GROUP="${{ parameters.resourceGroupName }}"

        echo "Artifact hash: $ARTIFACT_HASH"

        set +e
        EXISTING_HASH=$(az functionapp config appsettings list \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --query "[?name=='DEPLOY_PACKAGE_HASH'].value" \
          -o tsv 2>/dev/null)
        CLI_EXIT=$?
        set -e

        if [ $CLI_EXIT -ne 0 ]; then
          echo "No existing deployment hash found (function app config unavailable). Defaulting to deploy."
          SHOULD_DEPLOY=true
          EXISTING_HASH=""
        elif [ -z "$EXISTING_HASH" ]; then
          echo "No previous deployment hash stored. Function app will be updated."
          SHOULD_DEPLOY=true
        elif [ "$EXISTING_HASH" = "$ARTIFACT_HASH" ]; then
          echo "Artifact hash matches deployed hash. Skipping function app redeployment."
          SHOULD_DEPLOY=false
        else
          echo "Artifact hash differs from deployed hash. Function app will be updated."
          SHOULD_DEPLOY=true
        fi

        echo "Current deployed hash: ${EXISTING_HASH:-<none>}"
        echo "##vso[task.setvariable variable=ExistingFunctionsHash]$EXISTING_HASH"
        echo "##vso[task.setvariable variable=ShouldDeployFunctions]$SHOULD_DEPLOY"
    continueOnError: false

  - script: |
      echo "Functions artifact unchanged from last deployment. Skipping publish step."
    displayName: "Skip Functions Deployment"
    condition: and(succeeded(), eq(variables['ShouldDeployFunctions'], 'false'))

  # Install production dependencies (node_modules excluded from artifact)
  - script: |
      cd $(System.ArtifactsDirectory)/${{ parameters.artifactName }}/functions

      echo "Installing production dependencies..."
      npm ci --production --no-audit --no-fund

      if [ $? -ne 0 ]; then
        echo "##vso[task.logissue type=error]Failed to install dependencies"
        exit 1
      fi

      echo "Dependencies installed successfully"
      echo "node_modules size:"
      du -sh node_modules 2>/dev/null || echo "node_modules directory created"

      echo "Total files in functions directory:"
      find . -type f | wc -l
    displayName: "Install Backend Dependencies"
    condition: and(succeeded(), eq(variables['ShouldDeployFunctions'], 'true'))

  # Deploy Azure Functions
  - task: AzureFunctionApp@2
    displayName: "Deploy Azure Functions to ${{ parameters.environment }}"
    condition: and(succeeded(), eq(variables['ShouldDeployFunctions'], 'true'))
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      appType: "functionApp"
      appName: "${{ parameters.functionAppName }}"
      package: "$(System.ArtifactsDirectory)/${{ parameters.artifactName }}/functions"
      deploymentMethod: "auto"
      runtimeStack: "NODE|22"

  # Wait for Function App to be ready
  - script: |
      echo "Waiting for Function App to be ready..."
      sleep 30
      echo "Function App should be ready for health checks"
    displayName: "Wait for Function App Startup"
    condition: and(succeeded(), eq(variables['ShouldDeployFunctions'], 'true'))

  # Persist newly deployed hash to app settings for future runs
  - task: AzureCLI@2
    displayName: "Persist Functions Deployment Hash"
    condition: and(succeeded(), eq(variables['ShouldDeployFunctions'], 'true'))
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      scriptType: "bash"
      scriptLocation: "inlineScript"
      inlineScript: |
        set -euo pipefail

        APP_NAME="${{ parameters.functionAppName }}"
        RESOURCE_GROUP="${{ parameters.resourceGroupName }}"
        ARTIFACT_HASH="$(FunctionsArtifactHash)"

        echo "Storing deployment hash on function app..."
        az functionapp config appsettings set \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --settings DEPLOY_PACKAGE_HASH="$ARTIFACT_HASH" \
          --output none

        echo "✓ Deployment hash updated successfully"

  # Get Function App URL and Function Key
  - task: AzureCLI@2
    displayName: "Get Function App URL and Key"
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      scriptType: "bash"
      scriptLocation: "inlineScript"
      inlineScript: |
        echo "Querying Function App details..."

        # Get Function App hostname
        FUNCTION_APP_HOSTNAME=$(az functionapp show \
          --name ${{ parameters.functionAppName }} \
          --resource-group ${{ parameters.resourceGroupName }} \
          --query defaultHostName -o tsv)

        if [ -z "$FUNCTION_APP_HOSTNAME" ]; then
          echo "##vso[task.logissue type=error]Failed to get Function App hostname"
          exit 1
        fi

        FUNCTION_APP_URL="https://${FUNCTION_APP_HOSTNAME}"
        echo "Function App URL: $FUNCTION_APP_URL"
        echo "##vso[task.setvariable variable=functionAppUrl]$FUNCTION_APP_URL"

        # Get default function key for smoke tests
        echo "Retrieving function key..."
        FUNCTION_KEY=$(az functionapp keys list \
          --name ${{ parameters.functionAppName }} \
          --resource-group ${{ parameters.resourceGroupName }} \
          --query "functionKeys.default" -o tsv)

        if [ -z "$FUNCTION_KEY" ]; then
          echo "##vso[task.logissue type=error]Failed to retrieve function key"
          exit 1
        fi

        echo "Function key retrieved successfully"
        echo "##vso[task.setvariable variable=functionKey;issecret=true]$FUNCTION_KEY"

  # Run smoke tests if enabled
  - ${{ if eq(parameters.runSmokeTests, true) }}:
      - script: |
          echo "=========================================="
          echo "FUNCTION APP SMOKE TESTS"
          echo "=========================================="
          echo ""
          echo "Function App URL: $(functionAppUrl)"
          echo "Environment: ${{ parameters.environment }}"
          echo ""

          # Test 1: Health Check Endpoint
          echo "Test 1: Health Check Endpoint"
          echo "GET $(functionAppUrl)/api/health"

          HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" "$(functionAppUrl)/api/health")
          HEALTH_STATUS=$(echo "$HEALTH_RESPONSE" | tail -n1)
          HEALTH_BODY=$(echo "$HEALTH_RESPONSE" | head -n-1)

          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "✓ Health check passed (HTTP $HEALTH_STATUS)"
            echo "Response: $HEALTH_BODY"
          else
            echo "✗ Health check failed (HTTP $HEALTH_STATUS)"
            echo "Response: $HEALTH_BODY"
            echo "##vso[task.logissue type=error]Health check endpoint returned HTTP $HEALTH_STATUS"
            exit 1
          fi

          echo ""

          # Test 2: GetSetList Endpoint (with function key)
          echo "Test 2: GetSetList Endpoint"
          echo "GET $(functionAppUrl)/api/sets?code=***"

          SETS_RESPONSE=$(curl -s -w "\n%{http_code}" "$(functionAppUrl)/api/sets?code=$(functionKey)")
          SETS_STATUS=$(echo "$SETS_RESPONSE" | tail -n1)
          SETS_BODY=$(echo "$SETS_RESPONSE" | head -n-1)

          if [ "$SETS_STATUS" = "200" ]; then
            echo "✓ GetSetList endpoint passed (HTTP $SETS_STATUS)"
            
            # Verify response contains data (array returned directly, not wrapped in .data)
            SET_COUNT=$(echo "$SETS_BODY" | jq -r 'length' 2>/dev/null || echo "0")
            echo "Sets returned: $SET_COUNT"
            
            if [ "$SET_COUNT" -gt "0" ]; then
              echo "✓ Response contains set data"
            else
              echo "##vso[task.logissue type=warning]Response contains no set data"
            fi
          else
            echo "✗ GetSetList endpoint failed (HTTP $SETS_STATUS)"
            echo "Response: $SETS_BODY"
            echo "##vso[task.logissue type=error]GetSetList endpoint returned HTTP $SETS_STATUS"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "✓ All smoke tests passed"
          echo "=========================================="
        displayName: "Run Function App Smoke Tests"
        continueOnError: false

  # Display deployment summary
  - script: |
      echo "=========================================="
      echo "DEPLOYMENT SUMMARY"
      echo "=========================================="
      echo ""
      echo "Environment: ${{ parameters.environment }}"
      echo "Function App: ${{ parameters.functionAppName }}"
      echo "Resource Group: ${{ parameters.resourceGroupName }}"
      echo "Function App URL: $(functionAppUrl)"
      echo ""
      echo "Deployment completed successfully!"
      echo ""
      echo "Available endpoints:"
      echo "  - Health Check: $(functionAppUrl)/api/health"
      echo "  - Get Sets: $(functionAppUrl)/api/sets"
      echo "  - Get Cards: $(functionAppUrl)/api/cards/{setId}"
      echo "  - Get Card Info: $(functionAppUrl)/api/card/{cardId}"
      echo ""
      echo "=========================================="
    displayName: "Display Deployment Summary"
